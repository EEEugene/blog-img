# C++：

## 重载重写隐藏的区别

* **重载**就是同名函数，但类型不同或者说**参数个数不同**，**参数顺序不同**，这个叫重载，静态多态；动态多态就是虚函数

* **重写** 或者说叫**覆盖**，**直接把整个函数都重写了**，比如说我自己的Qt项目里面就是把鼠标移动这个事件给重写了，让他可以跟随窗口移动

*  **隐藏 **：子类中定义了与父类中同名的方法或属性，从而“隐藏”了父类中的方法或属性。当在子类中调用同名的方法或属性时，会调用子类中的实现，而非父类中的实现。

  

  区别：隐藏和重载范围不同，隐藏发生在不同类中

  参数区别：隐藏和被隐藏的函数参数列表可以相同，也可以不同，但函数名一定要相同；

  当参数不同时，无论基类中的函数是否被virtual所修饰，基类都会被隐藏而不是重写。

  重载强调**函数名称的多态性**，而重写**强调对象之间的多态性**。重载是编译时的多态，而重写是运行时的多态。

## 面向对象三大特征

封装、继承、多态

多态：公交车的例子，学生卡，普通人，老人卡，同样的行为但是产生不一样的结果

多态的实现主要分为静态多态和动态多态，静态多态主要是**重载**，在编译的时候就已经确定；动态多态是用**虚函数机制**实现的，在运行期间动态绑定。

虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖（重写）是**动态**态绑定的多态，而重载是**静态绑定**的多态。

封装：把一个客观的实物抽象成类，每个类对他自己的数据和方法实行protection(共有，私有，保护）

继承：广义的继承有三种方式：实现继承、可视继承、接口继承

## 如何理解面向对象?

面向对象就是看事物的一种方式，一种视觉角度，分析方式，我们可以把任意一个事物看成 是一个对象，**分析它身上具备的主要特征**，这个就是面向对象思维； 我们把事物当做一个对象，分析它的主体特征，注意力聚焦在主体特征，而不是聚焦于更细 节的内容及实现；比如我们把手机当做一对象，现在我们要开发手机，手机是个对象，它有哪 些特征呢，比如颜色、手机壳、打电话、发短信等等，而我们不会去想到 发短信具体是怎么 实现的，集成电路如何设计，如何接收信号，电磁波如何发出，甚至更加细节的问题； 这样做有利于我们宏观掌控设计手机的主体功能，在整体上思考设计方针的准确性，等我们 确定了每一个功能模块，主体特征后，我们在考虑如何一步一步去实现这个主体特征； 把事物当做对象，宏观分析它的具备的主体特征，这已经是面向对象的思维了。

​    面向对象和面向过程是两种不同处理问题的角度，面向过程**更注重事情的每一个步骤**，而面向对象则是更注**重参与一件事情里有多少个对象，并且分别需要做什么**。

​    举个例子，比如说我要用热水壶煮茶：

​    面向过程时——打开水壶——给水壶装水——放入茶叶——加热/煮——水沸腾进入保温——倒出；

​    而面对象则是：人——打开水壶、装水、放入茶叶、倒出

​                 水壶——进行加热、沸腾后自动检测并进入保温

​    由此可见面向过程比较直接高效，而面向对象则更**易于复用、扩展和维护**

## C++ 五个分区

堆区、栈区、静态（全局）区（static）、常量区、代码区

## C++中四种类型转换是：

static_cast, dynamic_cast, const_cast, reinterpret_cast

C的转换看起来强大，其实转换不够明确，不能进行错误检查，容易出错

函数声明时加上explicit可以阻止函数参数被隐式转换。

## 为什么栈的速度比堆快？

首先, 栈是本着LIFO原则的存储机制, 对栈数据的定位相对比较快速, 

而堆则是随机分配的空间, 处理的数据比较多, 无论如何, 至少要两次定位.

栈是在**一级缓存**中做缓存的, 而堆则是在**二级缓存**中, 两者在硬件性能上差异巨大.

## 指针和引用的区别？

指针是一个**变量**，引用只是一个**别名**；

用sizeof看指针的时候是**4**，而引用的话得看**被引用对象的大小**；

指针可以有**多级指针**，引用只有**一级**；

有const指针，但没有const引用

指针和引用都是用来访问内存中的数据的，它们在以下情况下是相同的：

1. 传递参数时：指针和引用都可以用于传递函数参数。在这种情况下，它们可以被用来修改传递给函数的参数的值。
2. 访问数组元素时：指针和引用都可以用来访问数组元素。
3. 访问对象成员时：指向对象的指针和对象的引用都可以用来访问对象的成员。

但是，指针和引用之间还有一些重要的区别。例如，指针可以被重新赋值为指向另一个对象，而引用必须在创建时初始化，并且不能被改变指向其他对象。此外，指针可以为空（NULL），而引用始终指向某个对象。

## 指针常量和常量指针的区别？

指针常量和常量指针是两种不同的概念。

1. 指针常量：指针常量是指一个指针被声明为常量，即指针本身的值不能修改。但是指针所指向的内存地址中的内容可以被修改。例如：

```
int x = 5;
int * const ptr = &x; // 声明ptr为指向int类型的常量指针
*ptr = 10; // 通过ptr修改x的值为10
```

在上面的例子中，ptr被声明为一个指向int类型的常量指针。这意味着ptr的值不能被修改（也就是ptr不能指向其他内存地址），但是我们仍然可以通过ptr来修改它所指向的内存地址中的内容。

1. 常量指针：常量指针是指一个指针所指向的内存地址中的内容被声明为常量，即内存地址中的内容不能被修改。但是指针本身的值可以被修改。例如：

```
int x = 5;
const int *ptr = &x; // 声明ptr为指向常量int类型的指针
// *ptr = 10; // 编译错误，不能修改ptr所指向的内存地址中的内容
x = 10; // 可以通过其他方式修改x的值
```

在上面的例子中，ptr被声明为一个指向常量int类型的指针。这意味着我们不能通过ptr来修改它所指向的内存地址中的内容，但是我们仍然可以通过其他方式来修改该内容（例如直接修改变量x的值）。同时，指针ptr的值可以被修改，即ptr可以指向其他内存地址。

## 链表、数组的区别？

数组是连续的空间，声明时就要确定长度；链表是一块可以不连续的，声明时不用确定长度；数组线性查找速度，链表需要按顺序检索检点，效率低；链表不会越界，数组有可能会越界；

## 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；
而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。
操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。

## vector和list的区别？

vector和list是C++ STL中两种不同的数据结构，它们之间的区别主要有以下几个方面：

1. 存储方式：vector是基于连续内存空间实现的动态数组，而list是基于双向链表实现的。
2. 访问效率：vector支持随机访问，可以通过下标直接访问元素，因此访问效率比较高；而list只支持顺序访问，无法通过下标直接访问元素，需要遍历列表才能访问指定元素，因此访问效率比较低。
3. 内存分配：vector在创建时需要预先分配一段连续的内存空间，如果需要增加容量，则需要重新分配更大的连续内存空间并将原有数据复制到新的内存中；而list则可以动态地分配和释放内存，插入或删除元素时，只需要调整节点的指针即可，不需要移动其他元素。
4. 插入和删除操作：由于vector底层实现是数组，因此在中间位置插入或删除元素时，需要将后续元素依次移动，因此效率较低；而list通过修改节点的指针来完成插入和删除操作，因此效率较高。
5. 迭代器失效：由于vector底层实现是数组，所以在对vector执行添加、删除操作时，可能会导致迭代器失效；而list的节点不会被移动，因此在对list进行添加、删除操作时，迭代器仍然有效。

总体来说，当需要快速随机访问元素时，应该使用vector；当需要频繁的插入和删除操作，并且不需要随机访问元素时，应该使用list。

## class和struct的区别？

在C++中，class和struct做类型定义是只有两点区别：

默认继承权限不同，class继承默认是**private继承**，而struct默认是**public继承**

class还可用于**定义模板参数**，像typename，但是关键字struct不能同于定义模板参数 C++保留struct关键字，原因

保证与C语言的向下兼容性，C++必须提供一个struct

C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制

对struct定义的扩展使C语言的代码能够更容易的被移植到C++中

## C 语言的关键字 static 和 C++ 的关键字 static 有什么区别

在 C 中 static 用来修饰**局部静态变量**和**外部静态变量**、函数。而 C++中除了上述功能外，还用来**定义类的成员变量和函数**。即静态成员和静态成员函数。

注意：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。

## 定义一个static成员函数有什么作用

定义一个 `static` 成员函数，可以使该函数独立于类的任何对象，也就是说，它可以直接通过类名调用，而不需要依赖于任何特定的类实例。

这种方式非常有用，因为 `static` 成员函数可以在不创建类实例的情况下执行某些操作，比如：

1. 计算、转换或验证输入数据；
2. 操作静态成员变量或全局变量；
3. 实现单例模式；
4. 提供实用工具函数等；

从性能和设计角度考虑，使用 `static` 成员函数可以避免创建对象时的开销，同时保持代码的可读性和可维护性。

## C++空类有哪些默认的函数

在 C++ 中，空类指的是没有任何成员变量或成员函数的类。对于空类，编译器默认会生成以下几个函数：

1. **默认构造**函数（Default Constructor）：如果用户没有定义任何构造函数，则编译器会自动生成一个无参构造函数，用于创建该类的对象。
2. **复制**构造函数（Copy Constructor）：如果用户没有定义复制构造函数，则编译器会自动生成一个默认的复制构造函数，用于将一个对象的值复制到另一个对象中。
3. **赋值**运算符（Assignment Operator）：如果用户没有定义赋值运算符，则编译器会自动生成一个默认的赋值运算符，用于将一个对象的值赋给另一个对象。
4. **析构**函数（Destructor）：如果用户没有定义析构函数，则编译器会自动生成一个默认析构函数，用于在对象销毁时释放资源。

这些默认函数的实现都是按照一定规则自动生成的，可以被重载、覆盖或删除。需要注意的是，如果类需要手动管理资源或有其他特殊需求，可能需要自己手动定义这些函数，以确保类的正确行为。

## 析构函数为什么要定义为虚函数

C++ 中，析构函数是用于释放对象占用的资源、清理数据成员并销毁对象自身的特殊成员函数。当一个类中定义了虚函数时，会生成一个虚函数表（Virtual Table），其中记录了该类所有虚函数的地址。在程序运行时，每个对象都有一个指向**虚函数表**的指针（Vptr）来实现动态绑定。

如果一个类中存在虚函数，且该类的对象被删除时，需要先调用对象的析构函数，然后再从虚函数表中查找并调用其基类的析构函数，以确保释放对象所占用的所有资源和内存空间。如果析构函数不是虚函数，则只会调用当前类的析构函数，而不会调用基类的析构函数，导致析构不完全，可能会出现内存泄漏等问题。

因此，在设计继承关系时，如果基类含有虚函数，那么可以将其析构函数定义为虚函数，以便在对派生类进行析构时能够正确地调用基类的析构函数，释放所有分配的内存并维护整个对象的正确状态。

总之，将析构函数定义为虚函数是一种良好的编程习惯，也是 C++ 中正确使用继承机制的必要条件，可以避免因析构不完全导致的各种错误，并确保程序的正确性和健壮性。

在 C++ 中，如果一个类含有虚函数，那么这个类的对象在被销毁时，需要调用其析构函数以释放资源和内存空间。当涉及到继承关系时，如果子类对象被销毁时只调用了自己的析构函数而没有调用父类的析构函数，那么可能会导致父类中资源没有被正确地释放，出现**内存泄漏等**问题。

为了避免这种情况的发生，需要将基类的析构函数定义为虚函数。这样，在通过基类指针或引用删除指向派生类对象的指针或引用时，会先调用派生类的析构函数，再调用基类的析构函数，保证所有的资源都能够被正确地释放。

因此，如果你的类涉及到继承关系并且其中包含有虚函数，那么就应该将析构函数定义为虚函数，以确保程序不会出现因析构顺序错误而导致的各种问题。

## static变量存在哪个区

在 C++ 中，`static` 变量分配在**静态存储区**中，也称为全局数据区或者 `.data` 段，而**函数内部创建**的**普通变量**在**栈**上分配内存。

静态存储区是一块固定的内存区域，在程序启动时被分配，直到程序退出时才被释放。所有 `static` 变量都在该区域中分配了固定的内存空间，并且它们在整个程序的生命周期内都存在。因此，一旦 `static` 变量被初始化，它们的值可以在程序的不同函数调用之间保持不变。

需要注意的是，静态存储区中的变量默认情况下会进行零初始化，也就是将变量的初始值设置为 0。如果 `static` 变量在定义时显式指定了初值，则其初值将覆盖默认的零初始化。

## 如何避免“野指针”

野指针是指指向未知、无效或已释放的内存地址的指针，它可能会导致程序崩溃或其他未定义行为。为了避免野指针的出现，可以采取以下几种方式：

1. **初始化**指针：确保指针在使用之前被初始化为一个有效的地址或空指针（nullptr），而不是随机的地址值。
2. 避免悬挂指针：当一个指针指向一个已释放的内存块时，该指针就成为了悬挂指针。为了避免悬挂指针的出现，应该尽量避免手动管理内存，而是使用**智能指针**等自动管理内存的工具。
3. 使用 const 和引用：在函数中参数使用 const 或者引用传递参数，可以避免因拷贝造成的野指针问题。
4. 查找指针错误：在程序运行过程中，如果发现程序出现了奇怪的行为或异常，可以利用调试工具查找指针错误。例如，使用 **Valgrind 工具检测内存泄漏**和非法访问等问题。
5. 确认指针生命周期：确保每个指针都有正确的生命周期，并且在不需要时及时释放该指针所占的内存空间。
6. 使用 **nullptr**：C++11 引入了一个新的关键字 nullptr，用于表示空指针。与 NULL 相比，nullptr 更加类型**安全**，**可以避免因隐式转换引起的潜在风险**。

综上所述，在编写 C++ 程序时，需要注意指针的使用，避免出现野指针等常见错误。如果遇到了问题，可以通过代码审查、测试和调试等手段找出并解决这些问题。

## 对于Windows下的内存泄漏我应该如何检测

在Windows下，可以使用一些内存泄漏检测工具来帮助我们找出程序中的内存泄漏问题。以下是一些常用的工具：

1. Visual Studio自带的内存泄漏检测工具：Visual Studio集成开发环境自带了一个名为“**Memory Diagnostic**”的内存泄漏检测工具。该工具会记录程序运行期间使用的内存信息，并提供详细的报告，以便于排查内存泄漏问题。
2. Windows Performance Toolkit：Windows Performance Toolkit包含一个名为“xperf”的命令行工具，可以通过它来检测应用程序的内存泄漏问题。这个工具可以帮助我们获取性能统计数据，包括 CPU、内存、磁盘和网络等方面的数据。使用xperf命令可以比较容易地收集到相应的数据，然后再通过其他工具进行分析。
3. 第三方内存泄漏检测工具：还有一些第三方工具，如BoundsChecker、Purify、Memcheck等，可以检测内存泄漏问题。这些工具都提供了全面的内存泄漏报告和堆栈跟踪信息，有助于开发人员准确地定位问题并解决。

总之，在Windows平台上检测内存泄漏问题需要综合考虑多种因素，包括开发语言、开发工具、运行环境等等。建议在实际项目中结合工具和实践进行检测和优化。

## 写文件时进程宕机，数据会丢失吗？

1. 如果进程在写文件时宕机，可能会导致数据丢失。具体来说，当进程调用 write 函数向磁盘写入数据时，操作系统会将数据缓存到内存中，然后再通过异步 I/O 的方式将数据写入磁盘。如果此时进程宕机了，那么未写入磁盘的数据就会丢失。

为了避免数据丢失的问题，可以使用一些可靠性策略，例如：

- 使用 fsync 函数将数据强制刷新到磁盘上。
- 定期备份数据并创建多个副本，以提高数据的可靠性和容错能力。
- 使用日志技术记录数据的修改历史，以便在出现异常情况时进行恢复。

## malloc是如何分配内存的？

在 C/C++ 中，malloc 函数用于动态分配内存。其原理如下：

1. 首先，当调用 malloc 函数时，操作系统会为进程分配一块**连续的虚拟地址空间**，并保留这段空间供进程使用。
2. malloc 函数会将这段空间划分为若**干个大小相等的内存块**，每个内存块都包含一个头部和数据部分，数据部分用于存储程序需要的数据。
3. 当程序向 malloc 函数请求一段特定大小的空间时，malloc 会按照一定的算法（如首次适配、最佳适配或者快速适配算法）从可用的内存块中选择一块合适的空间，并将该空间分配给程序使用。
4. 将分配得到的内存空间返回给程序，并记录该内存块的大小和位置信息，以备后续使用或释放操作时使用。

需要注意的是，由于 malloc 函数只分配了虚拟地址空间，因此这些空间可能并没有被物理内存所映射，而是采用了延迟分配（Lazy Allocation）技术，即只有当程序访问这些内存空间时，才会真正分配物理内存。如果物理内存不够用，操作系统还可以使用虚拟内存技术来为程序提供额外的内存空间。

另外，由于 malloc 分配的内存空间是动态的，因此程序需要注意及时释放不再使用的内存空间，以免造成内存泄漏和程序性能下降的问题。通常使用 free 函数来释放 malloc 分配的内存空间。

## free是如何释放内存的，怎么确定释放内存的大小？

在 C/C++ 中，free 函数用于释放由 malloc 或者 calloc 函数分配的内存空间。其原理如下：

1. 首先，程序需要**保证要释放**的内存地址是由 malloc 或者 calloc 函数分配得到的，否则可能会发生错误或者异常情况。
2. free 函数通过指定要释放的内存地址，将该内存块标记为**空闲状态**，以便后续的 malloc 或者 calloc 函数可以重新使用该内存块。
3. 在释放内存块之前，free 函数需要确定要释放的内存空间的大小，以便正确地更新内存管理数据结构和标记该内存块为空闲状态。通常情况下，这个大小信息是由 malloc 或者 calloc 函数记录在内存块头部的，可以通过指向内存块头部的指针来获取这个信息。

需要注意的是，由于 free 函数只是将内存块标记为**空闲状态**，并不会真正地清除内存中的数据内容，因此被释放的内存空间可能包含原有的数据信息，如果不小心读取这些内存空间，可能会导致非法访问和潜在的安全问题。因此，在调用 free 函数之后，建议将被释放的指针变量设置为 NULL，以避免意外访问。

另外，在多线程环境下，由于多个线程可能同时访问同一个内存块，因此需要保证内存释放的正确性和一致性。通常使用**互斥锁和同步机制**来控制对共享内存的访问和修改，以避免出现竞态条件和数据冲突等问题。

## new和delete是如何实现的？

new和delete是C++中动态内存分配的运算符，它们的实现依赖于操作系统提供的内存管理功能。

当使用new运算符时，它首先会在堆中分配一块大小合适的内存，并返回该内存块的地址。如果没有足够的空间来满足请求，将会**抛出std::bad_alloc异常**。然后，new会调用所需类型的构造函数来初始化对象。需要注意的是，new返回的指针**必须与所需类型相匹配**。例如，int* pi = new int; 将返回指向整数的指针。

相反，当使用delete运算符时，它首先调用所需类型的**析构函数**来销毁对象，然后**释放所占用的内存**。需要注意的是，在使用delete之前，必须保证指针指向的对象已经通过new进行了分配。否则，将会导致未定义行为。

需要注意的是，如果在使用new时分配了数组，那么必须使用delete[]运算符来释放该数组。同样地，如果在使用new时分配了单个对象，那么必须使用delete运算符来释放该对象。

## new和malloc的区别

`new` 和 `malloc` 都可以用于动态分配内存，但它们之间有以下几个区别：

1. `new` 是 C++ 的运算符，而 `malloc` 是 C 标准库函数。
2. `new` 会**自动调用构造函数**来初始化分配的内存，而 `malloc` 只是分配一段未初始化的内存空间。
3. `new` 返回的指针类型是**特定类型**的指针，而 `malloc` 返回的是 `void*` 类型的指针，需要手动进行强制类型转换。
4. `new` 抛出异常（`std::bad_alloc`），而 `malloc` 返回 `NULL` 来表示分配失败。
5. `new` 和 `delete` 必须成对使用，而 `malloc` 和 `free` 也必须成对使用。`new` 和 `delete` 自动管理对象的生命周期，而 `malloc` 和 `free` 需要程序员手动管理内存的生命周期。
6. 由于 `new` 需要调用构造函数和析构函数，所以只能用于类对象的创建和销毁，而 `malloc` 和 `free` 则可以用于任何类型的内存分配和释放。

总的来说，`new` 比 `malloc` 更加适合 C++ 程序员使用，因为它更加类型安全、具有更好的语义和异常检查等功能，而且可以自动管理对象的生命周期。但在某些特殊情况下，例如需要分配大量未初始化的内存块时，`malloc` 也可能比 `new` 更加有效。

## strlen和sizeof的区别？

sizeof是一个**操作符**，strlen是**库函数**。
sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。
编译器在编译时就计算出了sizeof的结果，而[strlen函数](https://so.csdn.net/so/search?q=strlen函数&spm=1001.2101.3001.7020)必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
数组做sizeof的参数不退化，传递给strlen就退化为指针了

## 深拷贝和浅拷贝的区别

深拷贝和浅拷贝是两种常见的对象拷贝方式，它们之间的区别在于拷贝时是否复制对象所包含的动态分配内存。

浅拷贝只是**简单地将一个对象的数据成员的值复制到另一个对象**中，这样得到的两个对象共享同一块动态分配内存。如果其中一个对象释放了内存，那么另一个对象也就不能再使用该内存了。因此，浅拷贝容易导致悬垂指针等内存问题。

深拷贝则会将**对象的所有数据成员都复制一份**，并为新对象**分配一块独立的动态分配内存**。这使得得到的两个对象互不干扰，并且不会出现由于释放内存而导致的悬垂指针等问题。

可以使用以下两种方式来实现深拷贝：

1. 重载复制构造函数或赋值运算符，手动完成对象数据成员的复制操作。
2. 利用智能指针等自动内存管理工具来完成数据成员的拷贝操作。

需要注意的是，深拷贝可能会涉及到对象内部的对象以及相关联的动态分配内存的复制，因此理解对象的拷贝语义非常重要。



## a 和&a 有什么区别

&a：其含义就是“变量a的地址”。
*a：用在不同的地方，含义也不一样。
在声明语句中，*a只说明a是一个指针变量，如int *a；
在其他语句中，*a前面没有操作数且a是一个指针时，*a代表指针a指向的地址内存放的数据，如b=*a；
*a前面有操作数且a是一个普通变量时，a代表乘以a，如c=ba。

## 什么是内联函数？它有哪些优点和缺点？

答：内联函数是一种编译时直接将函数体插入到调用它的代码中的函数。它的主要优点是可以**提高程序的执行效率，**因为避免了函数调用的开销。另外，内联函数还可以**减少代码的复制**和**堆栈空间的占用**。但是，内联函数也有一些缺点，比如**代码复杂度增加**、二进制代码大小增加等问题。

## 内联函数和宏定义的区别？

内联函数和宏定义都可以用于实现代码的优化，但它们之间存在一些区别。

1. 内联函数和宏定义都可以在调用时将函数体直接插入到代码中，但是两者的实现方式和作用略有不同。内联函数是由编译器在**编译时展开**，可以进行类型检查等操作，而宏定义是由**预处理器在编译前展开**，不能进行类型检查等操作，可能会导致类型错误或者意料之外的行为。内联函数虽然需要进行函数调用的开销，但能够进行类型检查，并具有更好的可读性和维护性。
2. **宏定义没有作用域限制**，会将所有符号出现的地方都进行替换，容易引起命名冲突和重复定义的问题。内联函数则可以像普通函数一样受到作用域的限制，避免了这些问题。
3. 宏定义不支持函数特性（如返回值、参数、函数重载等），并且代码可读性较差，容易产生难以排查的错误。内联函数则可以像普通函数一样使用所有函数特性，并且代码清晰易读。
4. 内联函数只是对编译器的建议，最终是否真正展开成内联代码由编译器决定。而宏定义始终会被展开成预处理后的代码。
5. 此外，内联函数还具有函数作用域、可重载等特性，而宏定义只是简单的字符串替换。因此，在C++中，应该优先使用内联函数来代替宏定义。

总之，内联函数相比于宏定义具有更好的**类型安全性、可维护性和可读性**，但有可能会增加**存储空间**和**代码长度**，也无法保证一定会被内联。宏定义适用于一些简单的代码替换场景，但容易引起问题，应该尽量避免滥用。

1. 内联函数是真正的函数，而宏定义只是简单地将一个代码片段替换为另一个代码片段。
2. 内联函数在编译时进行类型检查，因此会比宏定义更安全。宏定义没有类型检查，可能导致一些潜在的问题。
3. 内联函数可以使用C++高级特性，如函数重载、默认参数和指向成员函数的指针等。而宏定义不支持这些特性。
4. 内联函数可以避免函数调用带来的开销，并且可以提高代码执行效率。而宏定义虽然也可以达到相似的效果，但是会产生额外的代码冗余和可读性降低的问题。
5. 内联函数在编译时被展开，可以进行调试；而宏定义只是简单地替换代码，可能会造成调试困难。

总之，内联函数通常比宏定义更为安全、灵活和易维护，应该作为首选。但是，在某些情况下，如对于一些小的、简单的操作而言，使用宏定义能够使代码更加紧凑和高效。

## C和C++的类型安全？

C和C++在类型安全方面有一些区别。

C语言是弱类型的，比如可以将一个整型指针赋值给一个字符型指针，因为它们都是指针类型。这种类型转换可能会导致程序出现运行时错误，因此C语言的类型安全性相对较低。但是C语言提供了一些类型转换函数（如atoi、atof等）来减少这种问题的发生。

C++相对于C来说具有更好的类型安全性，它引入了严格的类型检查和类型转换规则，如const修饰符、函数重载、引用、模板等特性。这些特性大大改善了类型安全性，避免了由于类型转换不当而引起的错误。例如，在C++中，不允许将一个整型指针赋值给一个字符型指针，除非进行显式的强制类型转换。

此外，C++还提供了异常处理机制，使得程序可以在运行时捕获并处理错误，提高了程序的健壮性。

总之，C++相对于C来说具有更好的类型安全性，这使得编写程序变得更加健壮和可靠。但是开发人员仍然需要注意类型转换和类型检查等问题，以避免类型相关的错误。

## 初始化和赋值的区别？

初始化和赋值都是为变量或对象设置初始值的过程，它们之间的区别在于时间和语法。

初始化是在创建变量或对象时执行的操作，用于将其设置为某个特定的值。可以使用不同的方式进行初始化：默认初始化、值初始化、列表初始化和直接初始化等。例如：

```
int x; // 默认初始化（不指定初值）
int y = 0; // 值初始化
int z(42); // 直接初始化
int arr[]{1, 2, 3}; // 列表初始化数组
std::string str{"hello"}; // 列表初始化字符串
```

赋值是在变量或对象已经被创建后执行的操作，用于将其当前值改变为另一个值。赋值通常使用赋值运算符"="来完成。例如：

```
int a = 10;
a = 20; // 将a的值赋为20
```

总的来说，初始化和赋值都是用来给变量或对象赋值的过程，但它们发生的时间和语法上有所不同。初始化一般是在变量或对象创建时进行的，而赋值则是在变量或对象已经存在的情况下进行的；初始化可以使用多种方式来指定初值，而赋值通常使用赋值运算符"="来完成。

## mutable关键字

mutalbe的中文意思是“**可变的，易变的**”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。

我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。（使用mutable修饰的数据成员可以被const成员函数修改）。

## 类的对象存储空间？

类的对象存储空间取决于类的**数据成员和成员函数**，以及编译器如何对其进行内存布局。

通常情况下，类的对象存储空间包括以下几个部分：

1. 对象头：包含一些元信息，如**虚函数表指针**、类型信息等。如果类没有虚函数，则对象头可能为空。
2. 数据成员：类的数据成员占据大部分存储空间。根据访问权限和类型不同，数据成员可能被放在不同的区域中，如公有成员、私有成员等。
3. 对齐字节（padding bytes）：为了保证数据成员在内存中的对齐方式，编译器可能会在数据成员之间添加一些字节来填充空隙。
4. 对象尾部：对象尾部可能包含一些编译器自动生成的辅助代码或者其他元信息。

需要注意的是，由于编译器优化等原因，实际的对象存储空间可能会比上述描述更加复杂。例如，编译器可能会将多个数据成员合并到一个内存块中，或者使用内存池等技术来管理对象的分配和释放。

总之，类的对象存储空间是由编译器根据类的数据成员和成员函数定义生成的，包括对象头、数据成员、对齐字节和对象尾部等部分。了解类的对象存储空间可以帮助程序员更好地理解类的内部结构和内存布局，从而更加高效地开发程序。

## C++ 函数调用过程

总结起来整个过程就三步：
1）根据调用的函数名找到函数入口；
2）在栈中审请调用函数中的参数及函数体内定义的变量的内存空间
3）函数执行完后，释放函数在栈中的审请的参数和变量的空间，最后返回值（如果有的话）



## 23种设计模式和应用场景？

设计模式是针对特定问题的通用解决方案，而不是一种具体的算法或代码实现。在软件开发中，常用的设计模式包括23种，它们分别是：

1. 工厂方法模式：用于创建对象的接口，让子类决定实例化哪一个类。
2. 抽象工厂模式：提供一个接口，用于创建相关或相互依赖对象的家族，而无需指定具体类。
3. **单例**模式：确保一个类只有一个实例，并提供一个全局访问点。（任务管理器、计数器、回收站）
4. 建造者模式：将一个复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示。
5. 原型模式：通过复制现有的实例来创建新的实例。
6. 适配器模式：将一个类的接口转换成客户希望的另外一个接口。
7. 桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
8. 装饰器模式：动态地给一个对象添加一些额外的职责。
9. 组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。
10. 外观模式：为子系统中的一组接口提供一个一致的界面。
11. 享元模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. **观察者**模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
13. 中介者模式：用一个中介对象来封装一系列的对象交互。
14. 命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
15. 职责链模式：将请求的发送者和接收者解耦，使得多个对象都有机会处理这个请求。
16. **策略**模式：定义一系列的算法，把他们封装起来，并且使他们可以**相互替换**。
17. 模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中实现。
18. 迭代器模式：提供一种方法来访问聚合对象，而不需要暴露这个对象的内部表示。
19. 访问者模式：表示一个作用于某对象结构中的各元素的操作。
20. 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
21. 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
22. 状态模式：允许对象在其内部状态改变时改变它的行为。
23. 合成模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

这些设计模式可以应用于各种软件开发场景，例如构建高效、易于维护的系统、优化程序的性能、提升代码可读性、降低修改成本等。开发人员可以根据项目需求，选择适合的设计模式来提高代码质量和开发效率。

## 什么是简单工厂模式？

简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以 理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体 实现，只要告诉它你的需求即可。

## 什么是抽象工厂模式？

把咖啡抽象出来，今天想喝酒了，直接新建喝酒即可

## 什么是观察者模式？

也叫发布、订阅模式，观察者模式是一种行为型设计模式，它定义了对象之间的一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。

## 什么是装饰器模式？

装饰器模式是一种结构型设计模式，它允许我们在不改变对象接口的前提下，动态地给一个对象添加额外的功能。

优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式， 装饰模式可以动态扩展一个实现类的功能。 装饰器模式的关键：装饰器中使用了被装饰的对象。

## 什么是模板方法模式？

模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。

优点： 1. 提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子 类中； 2. 实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的 行为，实现了反向控制并且符合开闭原则。

## 什么是代理模式？

代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

优点： 1. 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度； 2. 可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。

 缺点： 1. 由于使用了代理模式，因此程序的性能没有直接调用性能高； 2. 使用代理模式提高了代码的复杂度。

## 策略模式？

策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。 

优点：遵循了开闭原则，扩展性良好。 

缺点：随着策略的增加，对外暴露越来越多。

# C++11：

## C++11有哪些新特性？

智能指针、右值引用、移动语义、auto关键字、nullptr关键字

## 什么是右值引用，跟左值又有什么区别？

在C++中，左值指的是可以取地址的表达式（即具有标识符的变量、对象或表达式），而右值指的是不可以取地址的表达式（如临时对象或字面量）。右值引用是一种用于引用右值的特殊类型的引用类型。

与左值引用相比，右值引用更加灵活，可以更好地支持移动语义、完美转发等特性，能够提高程序的效率和性能。

左值和右值的概念：

左值：能取地址，或者具名对象，表达式结束后依然存在的持久对象；
右值：不能取地址，匿名对象，表达式结束后就不再存在的临时对象；

区别：
左值能寻址，右值不能；
左值能赋值，右值不能；
左值可变，右值不能（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）；

## C++移动语义

C++移动语义是一种新的语言特性，它允许在函数参数和返回值中进行资源所有权的转移，从而提高了代码的效率和可读性。传统上，在C++中，当一个对象被传递给一个函数时，会进行复制构造函数的调用，这会导致对象的拷贝和额外的内存分配，从而影响程序的性能。移动语义通过使用右值引用和移动构造函数来避免这种情况。通过移动构造函数，可以将一个临时对象的资源所有权从原对象转移到另一个对象，从而减少了对象拷贝和内存分配的开销。

## 智能指针：

shared、weak、unique、   auto（98的方案，目前已经被c++11弃用）

传统指针 两个指向共同地址的指针，其中以后析构后,另一个没有值null的时候，A析构后，B就会报错；但是使用传统指针时需要手动管理内存，如申请/释放内存空间，避免内存泄漏等问题。
shared内部引用了计数器，增加的时候计数器+1，释放的时候减一，delete后不会立刻delete，而是变成0的时候才释放。

智能指针是为了尽可能的减少内存泄漏的情况。

智能指针相比传统指针更加安全和方便，可以有效地减少内存泄漏等错误。

* **内存泄漏**：申请的内存忘记释放，导致内存泄漏

- **内存溢出**：你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。
- **内存越界**：向系统申请了一块内存，而在使用内存时，超出了申请的范围

智能指针也会内存泄漏，可以用两个指针互相指向对方，会一直计数，然后导致内存泄漏，所以这个时候我们需要用weak来，weak不会增加计数。

## C++11 override，final关键字的作用？

- `override` 关键字：用于显式地指示一个虚函数是一个重写基类中的虚函数，从而在编译时检测这种错误。如果派生类中的函数签名与基类中的虚函数不匹配，则会产生编译错误，避免程序运行时出现意外结果。
- `final` 关键字：用于指示派生类**不能再继续继承**某个虚函数或者某个类，从而限制了继承链的长度，防止派生类进一步修改虚函数或者继续派生出新的类。
- 需要注意的是，`override` 和 `final` 关键字只能用于虚函数。如果在普通函数上使用这两个关键字，将会产生编译错误。

## C++11类型推导？

C++11 引入了自动类型推导（type inference）机制，也称为“类型推导”（type deduction），它可以让编译器在一定情况下推断出变量的类型，而无需程序员显式地指定类型。

C++11 中引入了两种类型推导方式：

`auto` 关键字：可以将变量的类型从变量初始化表达式中进行推导。

模板参数推导：可以用于推导函数模板或类模板的模板参数。

需要注意的是，虽然类型推导可以简化代码书写，但过度使用类型推导可能会降低代码的可读性和可维护性，因此需要在实际开发中权衡使用。同时，在某些特殊情况下，例如需要通过多次推导才能得到所需类型时，类型推导并不适用，这时还需要显式指定类型。

# 操作系统：

## 页面置换算法有哪些？

在操作系统中，为了最大化利用主存空间，需要使用页面置换算法来管理虚拟内存和物理内存之间的映射关系。常见的页面置换算法包括：

1. 先进先出算法（FIFO）：选择最早调入内存的页面进行替换，即选择队列头部的页面进行置换。
2. 最近最久未使用算法（LRU）：选择最长时间未被访问的页面进行替换，即选择最近最久未使用的页面进行置换。
3. 时钟算法（Clock）：以类似时钟指针的方式维护内存中所有页面的状态，根据页面是否被访问过和修改过来调整页面的状态，并选择一个非占用的页面进行替换。
4. 最不经常使用算法（LFU）：选择访问次数最少的页面进行替换，即选择被访问次数最少的页面进行置换。
5. 最佳置换算法（OPT）：预测每个页面在未来的一段时间内是否会被访问，并选择未来最长时间内不再使用的页面进行替换，即选择未来最久未使用的页面进行置换。

以上算法均有其优点和缺点，适用于不同的场景和应用场合。例如，FIFO 算法简单易实现，但可能导致较高的缺页率；而 LRU 算法能够更准确地反映页面的访问热度，但需要额外的数据结构来维护每个页面的状态。因此，在具体应用中需要根据实际情况选择最合适的页面置换算法。



## cas是怎样的一种同步机制？

CAS（Compare and Swap）是一种原子操作，用于实现并发环境下的同步机制。它通常被用于多线程编程中，用于保证数据的原子性和互斥性，从而避免出现竞态条件和数据冲突等问题。

CAS 操作包括三个参数：需要进行操作的内存地址、期望的值和新值。在执行 CAS 操作时，首先比较内存中的值是否等于期望的值，如果相等，则将内存中的值修改为新值，否则不做任何处理。

CAS 操作的流程如下：

1. 比较内存中的值是否等于期望的值；
2. 如果相等，则将内存中的值修改为新值，并返回 true；
3. 如果不相等，则不做任何处理，并返回 false。

由于 CAS 操作是原子性的，因此可以保证在多线程环境中，同一时间只有一个线程可以成功执行该操作，从而避免了数据竞争和并发问题。同时，CAS 操作也具有高效、轻量级等优点，适用于高并发场景和对性能要求较高的应用。

#  项目方面：

## 解析json

解析json时，一定要多多检查输入的合法性，避免非法输入造成程序崩溃。

用QJsonObject来进行解析JSON函数，然后我写了一个parseJson函数来进行解析，并且对应的JSON需要转换，比如说城市，可以让他转换成toString；比如说温度的话，就可以把它转换成toInt型；然后pm2.5的话就不能是int，需要转成double，一些小细节的话需要注意，避免非法输入导致程序崩溃。

## Qt核心？

Qt的核心是信号与槽函数，可以当成一个单独的独立模块使用。相对于c++需要用回调函数，但对于Qt，只需要简单的connect，只要一个简单的类来说就可以包含所有的类，可以在这个类里进行所有的connect，去调试来说也更加方便，我可以直接用qDebug来调试。

## Qt5、6版本区别？

Qt5为了兼容windows库，Qt6整个都进行了重构，就没有那些库了，用Qt6无法编译Qt5的库，区别很大,要去项目更改使用Qt5才能进行正常编译

Qt 6 不完全向后兼容 Qt 5，这意味着开发人员需要修改他们的代码以适应新的 API 和库。但是，Qt 6 提供了一些工具来帮助开发人员轻松地迁移他们的代码。

Qt 6 中的 **QML 引擎**比 Qt 5 中的更快，因为它使用了一个新的 Just-in-Time (JIT) 编译器。这意味着 Qt 6 中的 QML 应用程序将比 Qt 5 中的应用程序更加响应迅速。

C++11：Qt 6 要求使用 **C++11 标准**，而 Qt 5 只要求使用 C++98 标准。

Qt 6相对于Qt 5有一定的性能提升，特别是在渲染方面，同时也提供了更好的内存管理机制。

程序崩溃——调用了空指针，不该调用的值，设计上逻辑有bug

Qt界面卡死，逻辑，循环条件问题

## 内存释放相关问题

1. 对象树：如果一个QObject对象被设置了父对象，则在父对象析构时，会自动删除其所有子对象，无需手动释放。
2. 智能指针：Qt提供了多种智能指针（如QSharedPointer、QScopedPointer等），可以自动管理对象的生命周期，无需手动释放。
3. 垃圾回收器：从Qt 5.4开始，Qt引入了基于引用计数的跨线程垃圾回收器，称为QSharedPointer或者QPointer。

## Qt 6 提供了什么工具来帮助开发人员轻松地迁移他们的代码？

Qt 6 提供了以下工具来帮助开发人员轻松地迁移他们的代码：

1. Qt 6 **兼容性检查器**：Qt 6 包含一个用于识别在 Qt 5 代码中可能需要更新或修改的部分的兼容性检查器。该工具将输出详细的警告和错误消息，以帮助您确保代码能够平稳地迁移到 Qt 6。
2. Qt 6 **porting 导则**：Qt 6 还提供了一个包含有关如何从 Qt 5 迁移到 Qt 6 的详细信息的 porting 导则。该指南列出了 Qt 6 中已弃用或更改的 API，并提供有关如何更新您的代码以使用新的 API 的建议。
3. Qt Creator 工具链集成：Qt Creator 是 Qt 开发的官方 IDE，它通过提供支持 Qt 6 的编译器、调试器和其他工具来帮助开发人员轻松地将其代码迁移到 Qt 6。
4. 版本控制工具支持：Qt 6 支持常见的版本控制系统，例如 Git 和 Subversion，这些工具可帮助开发人员管理其代码库并轻松地跟踪更改。

## 什么是QWidget？它有哪些常用的子类？

QWidget是Qt中的一个**基本的窗口部件**，它提供了绘制、事件处理和布局管理等功能。QWidget的常用子类包括**QLabel、QPushButton、QLineEdit、QTextEdit**、QComboBox等。

QWidget是Qt中的一个基础类，用于实现GUI程序中的窗口部件（widget）。它是QWidget派生类的基类，提供了一些常见的界面元素和事件处理函数。QWidget是一个可视化的对象，可以添加到窗口或其他控件中，并与用户进行交互。

## QWidget的paintEvent()方法和drawWidget()方法有什么区别？

答：paintEvent()方法在widget需要重绘时被调用，可以在其中编写绘制代码；而drawWidget()方法则是QPainter在绘制widget时调用的一个虚函数，子类可以通过覆盖该函数实现自定义的绘制逻辑。

## QWidget的resizeEvent()方法和setFixedSize()方法有什么区别？

答：resizeEvent()方法在**widget的大小改变时**被调用，可以在其中进行相应的处理；而setFixedSize()方法则是**设置widget的固定大小**，当使用该方法时，widget将无法随着其内容的变化而自动调整大小。

## QWidget与QMainWindow的区别是什么？它们在使用上有何差异？

答：QWidget是Qt中的一个**基本窗口部件**，用于构建各种类型的窗口；而QMainWindow是一个具有**标准菜单栏、工具栏和状态栏的主窗口。**使用QWidget可以构建各种类型的自定义窗口，而使用QMainWindow则可以方便地创建具有标准窗口布局和标准UI元素的主窗口。

## QWidget的layout()方法有什么作用？它有哪些常用的布局管理器？

答：layout()方法用于获取widget的布局管理器，通过布局管理器可以实现widget内部的UI元素排列。QWidget支持多种布局管理器，包括QHBoxLayout、QVBoxLayout、QGridLayout和QFormLayout等。

## QSS的作用？

QSS是Qt框架中的一种样式表语言，类似CSS， 用于描述应用程序的外观和风格。它可以实现**动态修改应用程序的外观**，支持大量的样式属性，例如颜色、字体、边框等。QSS可以使开发人员快速构建个性化的应用程序，增强用户体验。

将QSS统一些在一个文件中，通过程序给主窗口加载；

## 如何在Qt中应用QSS？

答：可以在Qt代码中使用**setStyleSheet()**函数来加载QSS文件，如下所示：

```
cpp复制代码QString qss;
qss = "QPushButton { color: red }";
this->setStyleSheet(qss);
```

这里的qss是一个QString类型的变量，包含了要应用的样式内容，setStyleSheet()函数将该样式应用到当前对象上。

## QSS与CSS有哪些异同点？

答：QSS类似于CSS，但也有一些不同之处。QSS中可以使用一些额外的选择器来定位控件，**如QWidget、QPushButton**等。此外，QSS中还支持一些Qt特有的属性和值，如border-image、**qproperty**-*等。

## Qt信号槽机制的优点与缺点？

Qt信号槽（Signal-Slot）机制是一种用于对象间通讯的机制，主要用于实现GUI界面中的事件处理、用户交互等功能。其优点与缺点如下：

优点：

1. **松耦合**：信号槽机制使用松耦合方式，不需要直接调用函数或方法，从而减少了类之间的依赖关系，使得代码更加模块化。
2.  易于维护和扩展：信号槽机制可以在运行时动态连接和断开，便于代码的维护和扩展，使程序更加灵活。
3. 可重用性：由于信号槽机制是基于对象的，因此可以将信号和槽定义在一个基类中，从而实现代码的可重用性。
4. 多线程支持：Qt 的信号槽机制支持跨线程通讯，可以方便地实现多线程编程。
5. 不受操作系统平台限制：Qt 的信号槽机制是 Qt 自身实现的，不受操作系统平台的限制，因此可以轻松地实现跨平台应用程序。

缺点：

1. 运行效率：由于信号槽机制是通过**函数指针调用**实现的，因此相比于直接调用函数或方法，运行效率会稍微低一些。
2. 调试困难：由于信号槽机制是在运行时动态连接和断开的，因此它们的链接关系比较复杂，当出现问题时，调试起来可能会比较困难。

总的来说，Qt信号槽机制的优点包括松耦合、易于维护和扩展、可重用性、多线程支持以及跨平台等；缺点则包括运行效率和调试困难等。对于不同的情况，需要根据具体的需求来选择适合的编程方式。

## Qt信号和槽的本质？

Qt信号和槽（Signal-Slot）机制是一种用于对象间通讯的机制，主要用于实现GUI界面中的事件处理、用户交互等功能。它的本质是基于C++语言的面向对象编程思想和Qt框架提供的元对象系统实现的。

在C++中，对象的成员函数可以被另一个对象直接调用，但是这样会导致两个类之间的**耦合度很高，不利于代码的维护**。Qt信号槽机制通过使用**信号和槽**来解决这个问题。信号作为一种特殊的成员函数，与普通成员函数类似，不同的是信号不会被具体地实现，而是由QObject类提供的元对象系统来自动生成。当某个对象发生了特定事件时，例如按下按钮或文本框内容改变等，就会发送对应的信号。而槽则是一种普通的成员函数，用于接收并处理信号，实现特定的逻辑功能。

当一个信号连接到多个槽时，Qt框架会保证它们的执行顺序以及线程安全性。信号槽机制的实现依赖于Qt框架提供的元对象系统，其本质是将信号和槽映射为一个整数ID，并存储在对象的元数据中。当信号被触发时，Qt框架会在元数据中查找对应的槽，并以指针形式调用相应的成员函数。信号和槽机制是 Qt 的核心机制,可以让编程人员将互不相关的对象绑定在一起,实现对象之间的通信。 

总之，Qt信号槽机制是一种基于元对象系统的机制，通过信号和槽实现了对象间的松耦合通讯。

## Qt中的数据流和文件流（QtextStream）有什么区别？

在Qt中，数据流（QDataStream）和文件流（QFile）是用于**二进制**数据处理的工具，而文件流（QtextStream）是用于**文本数据**处理的工具。

QtextStream提供了一个包装器，它可以方便地将QIODevice对象转换为一个读取文本的流。QtextStream可以读取和写入Unicode字符串、UTF-8编码等，并且支持按行读取文本数据。与QDataStream不同，QtextStream并不是面向二进制数据的，而是面向文本数据的，因此不能直接读写二进制格式的数据。

另外，QtextStream还提供了许多文本操作函数，例如对齐、填充、跳过空格、插入字符串等，有助于开发人员更加方便地处理文本数据。同时，QtextStream也支持设置不同的字符编码格式，以便正确呈现各种语言和字符集。

综上所述，数据流和文件流（QDataStream和QFile）主要用于读写**二进制数据**，而文件流（QtextStream）则用于**读写文本数据**，并提供了更多针对文本数据的操作函数。

## Qt当中的show和exec的区别？

在Qt中，show()和exec()都是用于显示窗口的方法，但它们有一些区别。

**show()是QWidget类中的方法**，用于将窗口显示出来。调用show()方法后，窗口将被显示在屏幕上，并且用户可以与之交互。show()方法不会阻塞当前线程，所以程序会继续运行并执行接下来的代码。

例如：

```
Copy CodeQDialog dialog;
dialog.show();
// 程序会继续执行下面的代码
```

**而exec()是QDialog类中的方法**，用于显示一个模态对话框。调用exec()方法后，程序会被阻塞，直到对话框被关闭为止。这意味着，如果使用exec()方法显示对话框，程序必须等待用户输入数据或关闭对话框之后，才能继续执行接下来的代码。因此，exec()方法通常用于需要用户输入数据的场景，以确保获取正确的数据后再进行下一步操作。

例如：

```
Copy CodeQDialog dialog;
int ret = dialog.exec();
if (ret == QDialog::Accepted) {
    // 用户点击了“确定”按钮
} else {
    // 用户点击了“取消”按钮
}
```

总之，show()方法用于显示普通窗口，而exec()方法用于**显示模态对话框**，并且会阻塞主线程，直到对话框关闭为止。

## QString与基本数据类型如何转换？

需要注意的是，在将QString转换为基本数据类型时，要确保QString表示的内容可以正确地转换为该类型。如果QString无法转换为所需的类型，则会返回默认值。例如，当QString表示的内容无法转换为整数时，`toInt()`方法将返回0。

## 请说出Qt常用8类56个控件

好的，Qt 常用的 8 类 56 个控件如下：

1. 基础控件（13 个）：

- QLabel
- QPushButton
- QRadioButton
- QCheckBox
- QLineEdit
- QTextEdit
- QPlainTextEdit
- QComboBox
- QListWidget
- QSpinBox
- QDoubleSpinBox
- QSlider
- QProgressBar

1. 容器控件（7 个）：

- QWidget
- QFrame
- QGroupBox
- QTabWidget
- QStackedWidget
- QScrollArea
- QSplitter

1. 对话框控件（6 个）：

- QMessageBox
- QColorDialog
- QFontDialog
- QFileDialog
- QInputDialog
- QPrintDialog

1. 高级控件（7 个）：

- QCalendarWidget
- QDateTimeEdit
- QTimeEdit
- QListView
- QTreeView
- QTableWidget
- QMenu

1. 绘图与布局控件（12 个）：

- QGraphicsView
- QGraphicsScene
- QGraphicsItem
- QGraphicsPixmapItem
- QGraphicsTextItem
- QGraphicsRectItem
- QGraphicsEllipseItem
- QGraphicsLineItem
- QGraphicsPolygonItem
- QGraphicsGridLayout
- QHBoxLayout
- QVBoxLayout

1. 多媒体控件（4 个）：

- QMediaPlayer
- QVideoWidget
- QSoundEffect
- QCamera

1. 网络通信控件（4 个）：

- QTcpSocket
- QUdpSocket
- QTcpServer
- QNetworkAccessManager

1. 其他控件（3 个）：

- QWebEngineView
- QWebChannel
- QWebEnginePage

以上就是 Qt 常用的 8 类 56 个控件。

## Qt绘制原理双缓冲机制？

Qt绘制原理中的双缓冲机制是指在绘制过程中使用了两个缓冲区，一个**前台缓冲区**（也称为显示缓冲区），一个**后台缓冲区**（也称为绘图缓冲区）。前台缓冲区用于显示当前的图像，后台缓冲区用于绘制新的图像。当绘制完成后，将后台缓冲区中的图像复制到前台缓冲区中，从而实现**快速、平滑的绘制效果**。

具体地说，当需要刷新窗口或控件时，Qt会创建一个后台缓冲区，并将绘图操作发送到该缓冲区中进行。在绘制完成后，Qt将后台缓冲区中的图像复制到前台缓冲区中，最后再将前台缓冲区中的图像显示在屏幕上。这样可以避免在图像绘制过程中出现闪烁和撕裂等问题，同时也能够提高绘制效率和性能。

在Qt中，可以通过QWidget的paintEvent()函数来实现自定义绘制操作，开发人员可以在该函数中访问前/后台缓冲区，并对其进行读写操作。同时，Qt还提供了一些常用的绘图类，例如QPainter、QPen、QBrush等，可以方便地实现各种形状、颜色、渐变等效果的绘制。

总之，在Qt中，双缓冲机制是实现快速、平滑绘制效果的重要手段。通过合理利用前/后台缓冲区，开发人员可以实现更加灵活、高效的自定义图形绘制。

## Qt当中如何读写文件？

在Qt中，可以使用QFile类来读写文件。下面是一个简单的示例：

```
cppCopy CodeQFile file("example.txt");

if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine();
        // 处理每一行数据
    }
    file.close();
}

// 写入文件
if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
    QTextStream out(&file);
    out << "Hello, World!" << endl;
    out.flush();
    file.close();
}
```

在这个示例中，我们首先使用`QFile`打开一个名为`example.txt`的文件进行读取。然后，我们使用`QTextStream`从文件中逐行读取文本，并对每一行进行处理。

接下来，我们打开同一文件进行写入操作。然后使用`QTextStream`输出一些文本到文件中。最后，我们调用`flush()`方法将输出缓冲区中的内容刷新到磁盘上，并关闭文件。

请注意，在使用`QTextStream`时，您需要指定文件的文本模式。如果您需要以二进制模式读取或写入文件，则应该使用`QByteArray`和`QDataStream`类。

## Qt中事件过渡处理方法？

在Qt中，可以通过重写QObject类的eventFilter()方法来处理事件过渡。同时，也可以使用**事件过滤器**机制来处理事件过渡。

以下是使用事件过滤器来处理事件过渡的示例：

```c++
cppCopy Codeclass MyEventFilter : public QObject
{
public:
    bool eventFilter(QObject *obj, QEvent *event) override
    {
        if (event->type() == QEvent::Enter)
        {
            qDebug() << "mouse enter";
        }
        else if (event->type() == QEvent::Leave)
        {
            qDebug() << "mouse leave";
        }

        // 继续传递事件
        return QObject::eventFilter(obj, event);
    }
};

// 安装事件过滤器
MyEventFilter *filter = new MyEventFilter;
ui->label->installEventFilter(filter);
```

在上面的示例中，MyEventFilter类继承自QObject类，并重写了其eventFilter()方法。该方法接收两个参数：QObject对象和QEvent事件对象。当事件类型为鼠标进入或离开事件时，输出相应的提示信息。最后，返回QObject::eventFilter(obj, event)以继续将事件传递给下一个接收者。

在安装事件过滤器时，使用installEventFilter()方法将MyEventFilter类实例作为参数传递给要监视的对象。这样就可以在事件发生时触发eventFilter()方法对事件进行处理。

## QML鼠标与事件处理？QML布局？Loader动态加载组件？

在QML中，可以使用鼠标、键盘等设备输入来触发事件。QML中的Item对象有一些内置的鼠标事件处理函数，例如onClicked、onPressed、onReleased等。此外，还可以使用MouseArea组件来捕获和处理鼠标事件。

在QML中，可以使用各种布局管理器来自动排列控件。常见的布局管理器有Row、Column、Grid、StackView等。

Loader是QML中的一个组件，用于在运行时动态加载其他QML文件或组件。我们可以使用source属性来指定要加载的文件路径或组件名称，并使用active属性来控制是否加载该文件或组件。

## 多线程下，QT信号槽分别在什么线程中执行，如何控制？

Qt中connect函数的第五个参数是Qt::ConnectionType类型，用于指定连接的类型。它可以影响到信号和槽的执行顺序、线程间的通信方式、以及是否阻塞等行为。

可以通过connect的**第五个参数**进行控制信号槽执行时所在的线程；

connect有几种连接方式，**直接连接和队列连接、自动连接**

直接连接(Qt::DirectConnection) :信号槽在信号发出者所在的线程中执行

队列连接(Qt:QueuedConnection): 信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程执行

自动连接(Qt::AutoConnection): 多线程时为队列连接函数，单线程时为直接连接函数。

## 做过QT自定义控件吗？能举几个例子吗？

从外观设计上:QSS、继承绘制函数重绘、继承QStyle相关类重绘、组合拼装等等

从功能行为上:重写事件函数、添加或者修改信号和槽等等



# Linux：

## 硬链接和软连接的区别？

硬链接：共享文件、有类似智能指针一样的引用计数，直到计数为0的时候才算完全释放，有个inode

软连接：快捷方式

Linux命令可以修改文件的权限的是 `chmod` 命令。该命令用于修改文件或目录的访问权限，包括读取（r）、写入（w）和执行（x）等权限。`chmod` 命令可以通过数字或符号两种方式来指定权限，具体使用方法可以通过 `man chmod` 命令查看。

## 删除tmp文件的区别？

`rm -rf /tmp` 和 `rm -rf /tmp/*` 的区别在于：

- `rm -rf /tmp`：会递归删除 `/tmp` 目录及其下所有的文件和子目录，包括隐藏文件和目录。这意味着，如果 `/tmp` 目录下存在其他重要文件或目录（如系统服务所需的文件），它们也将被删除。
- `rm -rf /tmp/*`：仅删除 `/tmp` 目录下的所有非隐藏文件和子目录，并不会删除 `/tmp` 目录本身以及其中的隐藏文件和子目录。这意味着，如果 `/tmp` 目录下存在其他重要文件或目录（如系统服务所需的文件），它们不会被删除。

因此，在使用 `rm` 命令删除文件或目录时，需要谨慎操作，确保不要误删重要文件和目录。如果想要同时删除目录和其下所有内容，可以使用 `rm -rf` 命令，但需要确保删除的目录是自己创建的临时目录，而不是系统中的重要目录。同时，也可以使用其他命令，如 `find` 命令来删除特定类型或时间段内的文件，以避免误删其他文件。

## Linux 有哪些常见的 I/O 模型？它们之间的区别？

Linux 中常见的 I/O 模型有以下几种：

- 阻塞式 I/O：当应用程序调用 I/O 操作时，如果没有数据可读或者无法写入数据，I/O 调用将会一直阻塞，直到有数据可读或者可以写入数据。
- 非阻塞式 I/O：当应用程序调用 I/O 操作时，如果没有数据可读或者无法写入数据，I/O 调用会立即返回一个错误码，并不阻塞当前线程。应用程序需要通过轮询等方式来检查是否有数据可读或者是否可写入数据。
- I/O 多路复用（select/poll/epoll）：通过将多个 I/O 操作的状态都注册到一个统一的地方（如 epoll 实例）中，然后在一个线程内调用 select/poll/epoll 等系统调用来等待多个 I/O 操作的完成事件。这样就可以避免阻塞线程同时监听多个文件描述符。
- 信号驱动 I/O：当应用程序调用 I/O 操作时，将设置一个信号处理函数，当数据可读或者可写入数据时，内核会向应用程序发送一个信号，从而唤醒应用程序来处理 I/O 事件。
- 异步 I/O：当应用程序调用 I/O 操作时，I/O 调用会立即返回并不阻塞当前线程，应用程序只需在 I/O 完成后再进行处理。

这些 I/O 模型之间的主要区别在于应用程序与操作系统之间的 I/O 交互模式和同步机制不同，对应用程序的编程模型、性能以及响应时间等方面都会有影响。

## linux系统如何收发网络数据包？

在 Linux 系统中，网络数据包的发送和接收通常通过套接字（socket）进行。具体来说，套接字是网络编程中用于表示网络连接的一种抽象类型，可以用于实现不同层次的协议，例如 TCP、UDP、ICMP 等。

Linux 系统通过内核提供的网络协议栈来实现套接字的收发功能，其主要流程如下：

1. 创建套接字并绑定到指定的 IP 地址和端口号上，以便进行数据的传输和接收。
2. 发送数据：当调用 send 函数时，将待发送的数据通过套接字传递给内核，内核会对数据进行封装和分片，并通过网卡驱动将数据包发送出去。
3. 接收数据：当有数据包到达时，内核会将数据包拷贝到接收缓冲区中，并通知应用程序调用 recv 函数获取数据，或者通过回调函数直接处理数据。

在实际应用中，需要注意以下几点：

1. 使用合适的套接字类型和协议，例如 SOCK_STREAM 和 IPPROTO_TCP 用于实现 TCP 协议的数据传输，SOCK_DGRAM 和 IPPROTO_UDP 用于实现 UDP 协议的数据传输等。
2. 对于大量的小数据包传输，建议使用 writev 或者 sendmsg 函数进行批量发送，以降低系统调用的次数和系统开销。
3. 需要加强网络数据的安全性和可靠性，可以使用 TLS/SSL 加密协议、数据签名和认证技术等增强数据保护能力。
4. 在处理网络数据包时，需要注意防范恶意攻击和异常情况，例如拒绝服务攻击、缓存溢出、数据篡改等，加强对网络连接的监控和管理，提高系统的可靠性和安全性。

# 计网：

## 7层模型：

物理层 数据链路层 网络层 传输层 会话层  表示层 应用层；

## accept发生在三次握手的哪一步？

`accept` 函数是在 TCP 三次握手完成之后调用的。

当服务端使用 `socket`、`bind` 和 `listen` 等函数创建并监听一个套接字时，客户端可以通过 `connect` 函数向服务端发起连接请求。如果服务端接受连接请求，则会调用 `accept` 函数来接收新的连接，并返回一个新的套接字，这个新的套接字将用于服务端和客户端之间的通信。

在 TCP 三次握手过程中，当客户端发送 SYN 报文段（SYN 标志位被置为 1）时，服务端会回复 SYN+ACK 报文段（SYN 和 ACK 标志位都被置为 1），表示已经收到了客户端的连接请求，并准备好进行数据通信。当客户端收到服务端的 SYN+ACK 报文段后，会再次回复一个 ACK 报文段（ACK 标志位被置为 1），表示客户端已经收到了服务端的确认报文，连接已经建立成功，此时服务端才会调用 `accept` 函数。

## 大量close_wait的原因？

`CLOSE_WAIT` 状态是 TCP 协议中的一种状态。当一个客户端连接关闭时，发送了 `FIN` 报文并进入 `FIN_WAIT_1` 和 `FIN_WAIT_2` 状态。而服务端在接收到客户端的 `FIN` 报文后，也会返回一个 `ACK` 报文，并进入 `CLOSE_WAIT` 状态。此时，如果服务端没有及时关闭连接，则会出现大量的 `CLOSE_WAIT` 状态。

下面列举一些可能导致大量 `CLOSE_WAIT` 状态的原因：

1. 客户端异常退出：如果客户端在正常关闭连接之前发生异常退出，服务端将无法接收到客户端发送的最后一个 `ACK` 报文段，从而不能完成关闭操作，进入 `CLOSE_WAIT` 状态。
2. 服务端负载过高：如果服务端负载过高，处理关闭连接的时间变长，就会导致很多连接处于 `CLOSE_WAIT` 状态。
3. 网络延迟或丢包：如果网络环境不稳定，例如存在较高的延迟或者网络包丢失等情况，可能会导致 `ACK` 报文段未能及时到达服务端，从而延迟或阻塞服务端的关闭操作。
4. 调用 close 函数失败：如果服务端在关闭连接时调用 close 函数失败，也会导致连接处于 `CLOSE_WAIT` 状态。

解决方法包括增加服务端资源、优化网络环境、避免异常退出、以及使用 keepalive 等方式来保持连接可靠性，具体需要根据实际情况进行分析和处理。

## TCP 如何保证顺序？

TCP 协议中的数据传输都是**基于字节流**的，因此在传输过程中，数据可能会被分割成多个数据包进行传输。为了保证数据的顺序，TCP 协议使用了以下几种机制：

- **序列号**（Sequence Number）：每一个 TCP 报文段在发送前都会标记一个序列号，用于标记数据的顺序。
- **确认应答**（Acknowledgement）：接收方每次收到数据时都会发送一个确认应答，告诉发送方哪些数据已经成功接收到了，哪些数据还需要重传。
- **滑动窗口**（Sliding Window）：为了提高数据传输的效率，在 TCP 中使用了滑动窗口机制来允许一定程度上的乱序传输，不必等待所有数据都按照顺序传输完成再进行下一步操作。

因此，通过序列号、确认应答和滑动窗口等机制，TCP 可以在网络上可靠地传输数据并保证数据的顺序。

## tcp如何保证可靠性？

1. 确认和重传机制：当发送方发送数据时，接收方会给发送方发送一个确认消息，告知发送方已经收到了这些数据。如果发送方没有收到确认消息，则会认为数据包丢失，会重新发送该数据包，直到得到确认消息。
2. 滑动窗口机制：TCP 发送方和接收方之间维护一个窗口大小，用于控制数据流量的大小。发送方根据接收方的窗口大小控制发送的数据量，以避免发送过多的数据导致接收方无法处理。
3. 超时重传机制：如果发送方在规定时间内没有接收到接收方的确认消息，则会将该数据包视为丢失并进行重传。
4. 流量控制机制：TCP 在发送数据时，根据接收方的窗口大小来限制发送端的数据发送速率，避免过多的数据拥塞了接收方无法处理。
5. 拥塞控制机制：TCP 根据网络拥塞情况动态调整发送方的窗口大小和发送速率，以避免网络拥塞导致数据丢失和延迟增加。

总之，TCP 通过上述多种可靠性机制，实现了对数据传输的完整性、可靠性和有序性的保障，适用于各种应用场景，并广泛应用于互联网通信、文件传输、远程登录等方面。

## TCP UDP区别：

![image-20230319155210479](C:\Users\Eugene\AppData\Roaming\Typora\typora-user-images\image-20230319155210479.png)

**UDP 的实时性比 TCP 好**。

## 水平触发和边缘触发的区别？

水平触发和边缘触发是 epoll I/O 多路复用机制中的两种工作模式。

- 水平触发（Level-Triggered，简称 LT）：在水平触发模式下，当 epoll_wait 返回一个文件描述符时，如果该文件描述符上有数据可读或者可写入数据，则每次 epoll_wait 都会返回这个文件描述符。即 epoll_wait 只关心文件描述符上的数据是否可读或可写，如果可读或可写，就会一直返回该文件描述符，直到应用程序处理完相应的数据。
- 边缘触发（Edge-Triggered，简称 ET）：在边缘触发模式下，当 epoll_wait 返回一个文件描述符时，如果该文件描述符上有数据可读或者可写入数据，则只会通知一次。即 epoll_wait 只会通知应用程序文件描述符状态发生变化的一瞬间，而不是持续通知该文件描述符处于可读或可写状态。

因此，使用水平触发模式时，需要应用程序自己控制程序的逻辑，而使用边缘触发模式时，需要应用程序在处理事件时保证尽可能快速地处理完所有数据，否则可能会导致数据丢失或者阻塞。

## epoll 的惊群如何解决？

epoll 是 Linux 下的一种 I/O 多路复用机制，它可以帮助程序员在单线程下监听多个文件描述符，从而实现高效的事件驱动编程。

但是在 epoll 使用中会遇到惊群（thundering herd）问题，即当多个线程同时阻塞在同一个 epoll 文件描述符上等待事件发生时，当有事件触发时，所有线程都会被唤醒，但只有一个线程能够处理该事件，其他线程则需要重新进入等待状态，这样会浪费很多系统资源。

为了解决惊群问题，可以采用以下几种方法：

- 采用较新版本的 Linux 内核。Linux 2.6 版本的内核中引入了 EPOLLEXCLUSIVE 选项，可以使得在同一个 epoll 实例上等待的线程之间互斥并发，从而避免了惊群问题。

- 采用线程池或者工作队列等方式，将事件的处理逻辑交给专门的线程或者进程来处理，从而减少 epoll 等待事件的线程数，降低惊群问题的发生概率。

- 对于短时间内频繁触发的事件，可以采用 EPOLLONESHOT 选项来使得事件只被一个线程处理一次，并在处理完后将该事件从 epoll 实例中删除，避免多个线程同时处理同一个事件。

  

  

## 为什么会有协程？

协程是一种**轻量级的线程**，也被称为用户态线程。相比于操作系统所支持的线程，协程具有以下几点优势：

- 更小的内存开销：协程所需的内存比线程更少，因为协程没有独立的内存空间和栈，它们共享调用栈和堆栈。
- 更快的切换速度：协程切换时只需保存/恢复寄存器状态和栈指针等少量数据，因此切换速度更快。
- 更高的并发性：由于协程切换不需要操作系统介入，因此可以在单线程中支持大量的并发执行。

协程广泛应用于高并发、高吞吐量的场景，例如 Web 服务器、数据库、游戏服务器等领域。它们可以提供更加高效的任务调度、更好的负载均衡和更高的系统可伸缩性，从而提高了系统的性能和稳定性。



## 协程与网络io的关系？

协程与网络 I/O 有密切的关系。传统的网络编程（如使用 select/poll/epoll 等 I/O 多路复用方式）中，需要将 I/O 和其他业务逻辑分开处理，每个 I/O 操作都需要阻塞当前线程，从而导致 CPU 利用率低下、资源浪费等问题。而协程则可以在单线程内实现异步 I/O，将 I/O 阻塞和其他业务逻辑无缝地集成在一起，从而提高了程序的并发性。

具体来说，协程通过提供轻量级的线程切换机制，使得网络编程可以以同步方式编写，同时又能够实现异步 I/O。在协程模型中，当一个 I/O 操作发生时，当前协程会主动让出 CPU 资源，然后阻塞等待 I/O 完成。当 I/O 操作完成后，系统会唤醒相应的协程继续执行，从而实现异步 I/O 的效果。

协程的这种特性使得网络编程变得更加简单和高效。例如在协程框架下，可以使用同步方式编写数据库操作、HTTP 请求等耗时的 I/O 操作，不必担心对其他协程的影响，同时也可以避免大量线程上下文切换所带来的性能损失。因此，协程在异步编程中有着广泛的应用。

## tcp如何实现p2p？

TCP 是一种基于客户端-服务器（Client-Server）架构的通信协议，不直接支持 P2P（Peer-to-Peer）通信方式。但是，在实现 P2P 通信时，可以借助中介服务器（如 STUN/TURN 服务器），通过 NAT 穿透技术和端口映射技术来实现两个网络设备之间的直接通信。

具体来说，当两个设备需要建立 P2P 连接时，它们会向中介服务器发送请求，请求获取对方的 IP 地址和端口号，然后使用获取到的信息直接相互连接。如果设备处于私有网络环境中，则需要借助 NAT 穿透技术和端口映射技术来实现直接通信。

在实现 P2P 通信时，TCP 协议用于在两个设备之间建立可靠的、面向连接的数据传输通道，确保数据的完整性和正确性。同时，还可以借助 TCP 的流量控制和拥塞控制机制来优化数据传输效率，并减少网络拥塞和丢包的情况，提高通信的稳定性和可靠性。

## 什么是连接半打开，半关闭状态？

1. 连接半打开和半关闭状态指的是 TCP 协议中的连接状态。

- 连接半打开（Half-open）状态：指的是在客户端发送 SYN 报文给服务器端后，等待服务器端回复 SYN+ACK 报文的阶段。此时连接只有一个方向建立，还无法进行数据传输。
- 连接半关闭（Half-closed）状态：指的是在数据传输完毕后，其中一方调用 close 函数发起关闭请求，但另一方还可以继续发送数据的状态。此时连接只有一个方向关闭，仍可以进行单向数据传输。

通常情况下，TCP 状态转移图包括 CLOSED、LISTEN、SYN_SENT、SYN_RCVD、ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT、CLOSE_WAIT、 LAST_ACK 等状态。在实际应用中，需要根据不同的业务需求和网络环境来选择合适的状态转移策略，并加强对连接状态的管理和监控，以确保网络连接的稳定和可靠。

## ARP的协议是干什么的?

ARP（地址解析协议）是一种网络协议，用于将一个IP地址映射到一个物理硬件地址（如MAC地址）。它的主要作用是在通信之前，通过比较目标IP地址和本机的**ARP表**来确定目标设备的物理硬件地址。如果该信息不在缓存中，则会发送一个**广播消息**来请求该信息，这个过程被称为ARP请求。当目标设备响应时，它会将其物理硬件地址返回给请求方，这个过程被称为ARP响应。通过这种方式，ARP协议能够使设备之间进行通信。

# 数据库：

## MySQL 中不可重复读和幻读的区别？

不可重复读和幻读是 MySQL 数据库中经常出现的问题。

- 不可重复读：指在同一个事务中，由于其他事务的修改操作，导致某个查询语句的结果发生了改变。例如，在一个事务中连续查询同一条记录，但是查询的结果却出现了不同。
- 幻读：指在同一个事务中，由于其他事务的插入或删除操作，导致某个查询语句的结果集合发生了改变。例如，在一个事务中先查询某个范围内的数据，然后在该范围内插入了新的数据，再次查询该范围内的数据时，结果集合就发生了变化。

不可重复读和幻读的区别在于，前者是由**其他事务的修改操作**引起的，后者是由其他事务的**插入或删除操作**引起的。

为了解决这些问题，MySQL 提供了多版本并发控制（MVCC）机制。基本思想是采用版本号来标识每个事务的数据版本，读取数据时根据版本号判断是否是最新版本的数据，从而实现事务隔离性。具体实现方式包括快照读、当前读、锁定等。

## 主键索引和唯一索引的区别是什么？

主键索引和唯一索引都是用于提高查询效率和保证数据完整性的索引类型，它们之间的区别在于：

- 主键索引：主键索引是一种特殊的唯一索引，用于唯一标识每一行数据。一个表只能有一个主键索引，可以由一个或多个列组成，且该列不能为 NULL。
- 唯一索引：唯一索引也用于保证数据的唯一性，但与主键索引不同的是，唯一索引列可以包含 NULL 值，并且一个表可以存在多个唯一索引。

## 什么是回表查询？原理是什么？

回表查询指的是当 MySQL 数据库使用索引进行查询时，无法通过索引直接满足查询条件，需要进一步访问数据表获取完整的数据记录。这个过程也被称为二次查找或者非覆盖索引查询。

当 MySQL 数据库使用索引查询时，如果查询语句需要返回的数据列不在索引中，那么就需要通过索引值查询获取到数据行的主键，再根据主键到数据表中查询对应的数据行，这个过程就是回表查询。

回表查询虽然可以保证查询结果的正确性，但是会增加额外的 I/O 操作，降低查询效率。因此，在设计表结构时，可以考虑使用覆盖索引或者优化查询语句来避免回表查询的出现。

## 什么是覆盖索引？原理是什么？

覆盖索引指的是查询语句中需要的所有数据都可以从索引中得到，而无需再从数据表中去获取数据。这种索引可以减少磁盘 I/O 操作和 CPU 计算量，从而提高查询效率和响应时间。

实现覆盖索引的原理是将查询语句所需的字段都存储到索引中，使得查询语句可以直接通过索引来获取所有需要的结果，而不必再访问数据表。这样可以避免了大量的随机 I/O 操作和数据的传输，从而提高查询效率。

覆盖索引适合于查询较小的表和需要返回少量数据的查询场景，可以有效地减少系统的负担和提高查询的性能。

## 什么是索引下推？原理是什么？

索引下推（Index Condition Pushdown，简称 ICP）指的是 MySQL 数据库优化查询语句性能的一种技术，在执行查询时将 WHERE 条件下推到存储引擎层面，尽可能减少检索和过滤的数据量，从而提高查询效率。

当 MySQL 执行查询时，首先需要通过索引找到符合条件的行，然后再对这些行进行进一步的过滤操作。在使用 ICP 技术时，MySQL 可以将 WHERE 条件下推至存储引擎层面，先对索引进行过滤，只将符合条件的行访问到，因此可以避免大量无用的数据传输和过滤操作，从而提高查询效率。

## 数据库事务的四个特性以及含义？

数据库事务通常有四个特性，分别称为 ACID：

- 原子性（Atomicity）：事务被视为一个单独的逻辑单元，其所有操作要么全部成功，要么全部失败回滚。如果事务的任何部分失败，则整个事务都必须撤消。
- 一致性（Consistency）：事务应该将数据库从一种状态转换为另一种状态，这种状态应该确保满足所有预定义的约束和完整性规则。如果事务执行成功，则数据库应该处于一致状态。
- 隔离性（Isolation）：每个事务应该与其他正在执行的事务隔离开来，以防止它们互相干扰。每个事务应该似乎是独立运行的，不应该看到其他事务未完成的结果。
- 持久性（Durability）：一旦提交了一个事务，它所做的更改就应该永久保存在数据库中，并且即使在出现故障的情况下也应该得以恢复。

这四个特性确保了事务的正确性和可靠性，并且在并发环境中保证事务之间的正确交互和处理。

# 九大板块：

- C++语法块
- STL和现代C++，用法和底层原理、移动语义和右值引用
- 网络原理和网络编程：TCP\IP\UDP\HTTP\HTTPS\SOCKET编程\网络模型\IO多路复用 select poll epoll、reactor和proactor模型，现在问的多的是场景题
- 操作系统：多线程、多进程、线程同步、进程间通信、死锁、进程调度算法、内存、文件系统
- 常用的数据结构和算法：链表类算法（重排、反转、合并有序）、十大排序算法：快排、快排的优化、二叉树、avl树、红黑树、BFS\DFS思路原理
- 设计模式：单例、工厂、mvc
- 其他版块：看岗位、后台开发（数据库），QT开发（QT概念和原理）、音视频
- 项目：技术、遇到什么问题、怎么解决
- HR面试：自我介绍、优点、缺点、加班看法